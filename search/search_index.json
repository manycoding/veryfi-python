{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"veryfi is a Python module for communicating with the Veryfi OCR API Installation Install from PyPi using pip , a package manager for Python. Install the package from PyPI: pip install -U veryfi You may need to run the above commands with sudo . Getting Started Obtaining Client ID and user keys If you don't have an account with Veryfi, please go ahead and register here: https://hub.veryfi.com/signup/api/ Python API Client Library The veryfi library can be used to communicate with Veryfi API. All available functionality is described here https://veryfi.github.io/veryfi-python/reference/veryfi/#client Below is the sample script using veryfi to OCR and extract data from a document: from veryfi import Client client_id = 'your_client_id' client_secret = 'your_client_secret' username = 'your_username' api_key = 'your_password' categories = [ 'Grocery' , 'Utilities' , 'Travel' ] file_path = '/tmp/invoice.jpg' # This submits document for processing (takes 3-5 seconds to get response) veryfi_client = Client ( client_id , client_secret , username , api_key ) response = veryfi_client . process_document ( file_path , categories = categories ) response # or with url response = veryfi_client . process_document_url ( url , external_id = some_id ) response >>> { \"abn_number\" : \"\" , \"account_number\" : \"\" , \"bill_to_address\" : \"130 INTERSTATE BLVD, SUIT 21 \\n NASHEVILLE, NC 28806\" , \"bill_to_name\" : \"FAST ROOFING COMPANY, LLC\" , \"card_number\" : \"\" , \"category\" : \"Hardware Supplies\" , \"currency_code\" : \"USD\" , \"date\" : \"2019-08-01 00:00:00\" , \"due_date\" : \"2019-09-01\" , \"discount\" : 0 , \"external_id\" : \"\" , \"id\" : 28933541012 , \"img_thumbnail_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da_t.jpg\" , \"img_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da.pdf\" , \"invoice_number\" : \"1234568\" , \"line_items\" : [ { \"date\" : \"\" , \"description\" : \"SFTY TAGS LCKED OUT 250BX 426NS\" , \"discount\" : 0 , \"order\" : 1 , \"price\" : 200.0 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"PTW-901444\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 200.00 , \"type\" : \"purchase\" , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"WEDGE ANCHOR. PLATED\" , \"discount\" : 0 , \"order\" : 2 , \"price\" : 3.75 , \"quantity\" : 100 , \"reference\" : \"\" , \"sku\" : \"WA-12-414\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 375.00 , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"SYP #2 KD-HT UNTREATED\" , \"discount\" : 0 , \"order\" : 9 , \"price\" : 11.49 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"WE-27517\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 11.49 , \"unit_of_measure\" : \"pc\" } ], \"ocr_text\" : \" \\n ACE \\n The helpful place. \\n Ace Hardware \\t\\t\\t\\t\\t\\t INVOICE \\n 5726.....\" , \"payment_display_name\" : \"\" , \"payment_terms\" : \"\" , \"payment_type\" : \"\" , \"purchase_order_number\" : \"\" , \"reference_number\" : \"VBAJD-32541\" , \"shipping\" : 0 , \"subtotal\" : 586.49 , \"tax\" : 41.05 , \"tax_lines\" : [{ \"name\" : \"state tax\" , \"rate\" : 7.0 , \"total\" : 41.05 }], \"tip\" : 0 , \"total\" : 627.54 , \"vat_number\" : \"\" , \"vendor\" : { \"address\" : \"5726 Memorial Blvd, Saint George, SC 29477\" , \"name\" : \"Hutto Ace Hardware\" , \"raw_name\" : \"Ace Hardware\" , \"phone_number\" : \"(843) 563-4012\" , \"vendor_logo\" : \"https://cdn.veryfi.com/logos/us/953982859.png\" , \"vendor_type\" : \"hardware stores\" }, \"vendor_vat_number\" : \"\" , \"vendor_iban\" : \"\" , \"vendor_bank_number\" : \"\" , \"vendor_bank_name\" : \"\" } Update a document new_vendor = {\"name\": \"Starbucks\", \"address\": \"123 Easy Str, San Francisco, CA 94158\"} category = \"Meals & Entertainment\" new_total = 11.23 veryfi_client.update_docuement(id=12345, vendor=new_vendor, category=new_category, total=new_total) Need help? If you run into any issue or need help installing or using the library, please contact support@veryfi.com. If you found a bug in this library or would like new features added, then open an issue or pull requests against this repo! To learn more about Veryfi visit https://www.veryfi.com/ Tutorial Video","title":"Home"},{"location":"#installation","text":"Install from PyPi using pip , a package manager for Python. Install the package from PyPI: pip install -U veryfi You may need to run the above commands with sudo .","title":"Installation"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#obtaining-client-id-and-user-keys","text":"If you don't have an account with Veryfi, please go ahead and register here: https://hub.veryfi.com/signup/api/","title":"Obtaining Client ID and user keys"},{"location":"#python-api-client-library","text":"The veryfi library can be used to communicate with Veryfi API. All available functionality is described here https://veryfi.github.io/veryfi-python/reference/veryfi/#client Below is the sample script using veryfi to OCR and extract data from a document: from veryfi import Client client_id = 'your_client_id' client_secret = 'your_client_secret' username = 'your_username' api_key = 'your_password' categories = [ 'Grocery' , 'Utilities' , 'Travel' ] file_path = '/tmp/invoice.jpg' # This submits document for processing (takes 3-5 seconds to get response) veryfi_client = Client ( client_id , client_secret , username , api_key ) response = veryfi_client . process_document ( file_path , categories = categories ) response # or with url response = veryfi_client . process_document_url ( url , external_id = some_id ) response >>> { \"abn_number\" : \"\" , \"account_number\" : \"\" , \"bill_to_address\" : \"130 INTERSTATE BLVD, SUIT 21 \\n NASHEVILLE, NC 28806\" , \"bill_to_name\" : \"FAST ROOFING COMPANY, LLC\" , \"card_number\" : \"\" , \"category\" : \"Hardware Supplies\" , \"currency_code\" : \"USD\" , \"date\" : \"2019-08-01 00:00:00\" , \"due_date\" : \"2019-09-01\" , \"discount\" : 0 , \"external_id\" : \"\" , \"id\" : 28933541012 , \"img_thumbnail_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da_t.jpg\" , \"img_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da.pdf\" , \"invoice_number\" : \"1234568\" , \"line_items\" : [ { \"date\" : \"\" , \"description\" : \"SFTY TAGS LCKED OUT 250BX 426NS\" , \"discount\" : 0 , \"order\" : 1 , \"price\" : 200.0 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"PTW-901444\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 200.00 , \"type\" : \"purchase\" , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"WEDGE ANCHOR. PLATED\" , \"discount\" : 0 , \"order\" : 2 , \"price\" : 3.75 , \"quantity\" : 100 , \"reference\" : \"\" , \"sku\" : \"WA-12-414\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 375.00 , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"SYP #2 KD-HT UNTREATED\" , \"discount\" : 0 , \"order\" : 9 , \"price\" : 11.49 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"WE-27517\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 11.49 , \"unit_of_measure\" : \"pc\" } ], \"ocr_text\" : \" \\n ACE \\n The helpful place. \\n Ace Hardware \\t\\t\\t\\t\\t\\t INVOICE \\n 5726.....\" , \"payment_display_name\" : \"\" , \"payment_terms\" : \"\" , \"payment_type\" : \"\" , \"purchase_order_number\" : \"\" , \"reference_number\" : \"VBAJD-32541\" , \"shipping\" : 0 , \"subtotal\" : 586.49 , \"tax\" : 41.05 , \"tax_lines\" : [{ \"name\" : \"state tax\" , \"rate\" : 7.0 , \"total\" : 41.05 }], \"tip\" : 0 , \"total\" : 627.54 , \"vat_number\" : \"\" , \"vendor\" : { \"address\" : \"5726 Memorial Blvd, Saint George, SC 29477\" , \"name\" : \"Hutto Ace Hardware\" , \"raw_name\" : \"Ace Hardware\" , \"phone_number\" : \"(843) 563-4012\" , \"vendor_logo\" : \"https://cdn.veryfi.com/logos/us/953982859.png\" , \"vendor_type\" : \"hardware stores\" }, \"vendor_vat_number\" : \"\" , \"vendor_iban\" : \"\" , \"vendor_bank_number\" : \"\" , \"vendor_bank_name\" : \"\" } Update a document new_vendor = {\"name\": \"Starbucks\", \"address\": \"123 Easy Str, San Francisco, CA 94158\"} category = \"Meals & Entertainment\" new_total = 11.23 veryfi_client.update_docuement(id=12345, vendor=new_vendor, category=new_category, total=new_total)","title":"Python API Client Library"},{"location":"#need-help","text":"If you run into any issue or need help installing or using the library, please contact support@veryfi.com. If you found a bug in this library or would like new features added, then open an issue or pull requests against this repo! To learn more about Veryfi visit https://www.veryfi.com/","title":"Need help?"},{"location":"#tutorial-video","text":"","title":"Tutorial Video"},{"location":"CONTRIBUTORS/","text":"Release process Release and upload to pypi is set up in github actions. For that 2 conditions are required: * a correct version tag following Semantic versioning, e.g. 1.2.0 * merge to master Versioning pbr manages all the package metadata: * it uses requirements.txt * it adds version To check the package build, simply run python setup.py sdist bdist_wheel","title":"Contributors"},{"location":"CONTRIBUTORS/#release-process","text":"Release and upload to pypi is set up in github actions. For that 2 conditions are required: * a correct version tag following Semantic versioning, e.g. 1.2.0 * merge to master","title":"Release process"},{"location":"CONTRIBUTORS/#versioning","text":"pbr manages all the package metadata: * it uses requirements.txt * it adds version To check the package build, simply run python setup.py sdist bdist_wheel","title":"Versioning"},{"location":"reference/veryfi/","text":"Module veryfi None None View Source import base64 import hashlib import hmac import json import os import time from typing import * import requests from veryfi.errors import VeryfiClientError class Client : API_VERSION = \"v7\" API_TIMEOUT = 120 MAX_FILE_SIZE_MB = 20 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\" , \"Automotive\" , \"Bank Charges & Fees\" , \"Legal & Professional Services\" , \"Insurance\" , \"Meals & Entertainment\" , \"Office Supplies & Software\" , \"Taxes & Licenses\" , \"Travel\" , \"Rent & Lease\" , \"Repairs & Maintenance\" , \"Payroll\" , \"Utilities\" , \"Job Supplies\" , \"Grocery\" , ] def __init__ ( self , client_id , client_secret , username = None , api_key = None , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ): self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . timeout = timeout self . api_version = api_version self . headers = {} self . _session = requests . Session () def _get_headers ( self , has_files : bool = False ): \"\"\" Prepares the headers needed for a request. :param has_files: Are there any files to be submitted as binary :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/0.1\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } if self . username : final_headers . update ( { \"Authorization\" : \"apikey {} : {} \" . format ( self . username , self . api_key )} ) if has_files : final_headers . pop ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) return final_headers def _get_url ( self ): \"\"\" Get API Base URL with API Version :return: Base URL to Veryfi API \"\"\" return self . base_url + self . api_version def _request ( self , http_verb , endpoint_name , request_arguments , file_stream = None ): \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" has_files = file_stream is not None headers = self . _get_headers ( has_files = has_files ) api_url = \" {0} /partner {1} \" . format ( self . _get_url (), endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200 , 201 , 202 , 204 ]: raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ): \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp: {} \" . format ( timestamp ) for key in payload_params . keys (): value = payload_params [ key ] payload = \" {0} , {1} : {2} \" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ) . digest () base64_signature = base64 . b64encode ( tmp_signature ) . decode ( \"utf-8\" ) . strip () return base64_signature def get_documents ( self ): \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ): \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/ {} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path , categories = None , delete_after_processing = False ): \"\"\" Process Document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def _process_document_file ( self , file_path , categories = None , delete_after_processing = False ): \"\"\" Process Document by sending it to Veryfi as multipart form :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) request_arguments = { \"file_name\" : file_name , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } with open ( file_path ) as file_stream : document = self . _request ( \"POST\" , endpoint_name , request_arguments , file_stream ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List [ str ]] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List [ str ]] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments ) def delete_document ( self , document_id ): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/ {0} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { id } /\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) Sub-modules veryfi.errors Variables TYPE_CHECKING Classes Client class Client ( client_id , client_secret , username = None , api_key = None , base_url = 'https://api.veryfi.com/api/' , api_version = 'v7' , timeout = 120 ) View Source class Client : API_VERSION = \"v7\" API_TIMEOUT = 120 MAX_FILE_SIZE_MB = 20 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\", \"Automotive\", \"Bank Charges & Fees\", \"Legal & Professional Services\", \"Insurance\", \"Meals & Entertainment\", \"Office Supplies & Software\", \"Taxes & Licenses\", \"Travel\", \"Rent & Lease\", \"Repairs & Maintenance\", \"Payroll\", \"Utilities\", \"Job Supplies\", \"Grocery\", ] def __init__ ( self , client_id , client_secret , username = None , api_key = None , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ) : self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . timeout = timeout self . api_version = api_version self . headers = {} self . _session = requests . Session () def _get_headers ( self , has_files : bool = False ) : \"\"\" Prepares the headers needed for a request. :param has_files: Are there any files to be submitted as binary :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/0.1\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } if self . username : final_headers . update ( { \"Authorization\" : \"apikey {}:{}\" . format ( self . username , self . api_key ) } ) if has_files : final_headers . pop ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) return final_headers def _get_url ( self ) : \"\"\" Get API Base URL with API Version :return: Base URL to Veryfi API \"\"\" return self . base_url + self . api_version def _request ( self , http_verb , endpoint_name , request_arguments , file_stream = None ) : \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" has_files = file_stream is not None headers = self . _get_headers ( has_files = has_files ) api_url = \"{0}/partner{1}\" . format ( self . _get_url (), endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200, 201, 202, 204 ] : raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ) : \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp:{}\" . format ( timestamp ) for key in payload_params . keys () : value = payload_params [ key ] payload = \"{0},{1}:{2}\" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ). digest () base64_signature = base64 . b64encode ( tmp_signature ). decode ( \"utf-8\" ). strip () return base64_signature def get_documents ( self ) : \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ) : \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/{}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def _process_document_file ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document by sending it to Veryfi as multipart form :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) request_arguments = { \"file_name\" : file_name , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } with open ( file_path ) as file_stream : document = self . _request ( \"POST\" , endpoint_name , request_arguments , file_stream ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments ) def delete_document ( self , document_id ) : \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/{0}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/{id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) Class variables API_TIMEOUT API_VERSION BASE_URL CATEGORIES MAX_FILE_SIZE_MB Methods delete_document def delete_document ( self , document_id ) Delete Document from Veryfi Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_document(self, document_id): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/{0}/\".format(document_id) request_arguments = {\"id\": document_id} self._request(\"DELETE\", endpoint_name, request_arguments) get_document def get_document ( self , document_id ) Retrieve document by ID Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None Data extracted from the Document View Source def get_document ( self , document_id ) : \"\"\" Retrieve document by ID : param document_id : ID of the document you ' d like to retrieve :return : Data extracted from the Document \"\"\" endpoint_name = \" /documents/{}/ \" . format ( document_id ) request_arguments = { \" id \" : document_id } document = self . _request ( \" GET \" , endpoint_name , request_arguments ) return document get_documents def get_documents ( self ) Get list of documents Returns: Type Description None List of previously processed documents View Source def get_documents ( self ) : \"\"\" Get list of documents : return : List of previously processed documents \"\"\" endpoint_name = \" /documents/ \" request_arguments = {} documents = self . _request ( \" GET \" , endpoint_name , request_arguments ) if \" documents \" in documents : return documents [ \" documents \" ] return documents process_document def process_document ( self , file_path , categories = None , delete_after_processing = False ) Process Document and extract all the fields from it Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None categories None List of categories Veryfi can use to categorize the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None Returns: Type Description None Data extracted from the document View Source def process_document ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document and extract all the fields from it : param file_path : Path on disk to a file to submit for data extraction : param categories : List of categories Veryfi can use to categorize the document : param delete_after_processing : Delete this document from Veryfi after data has been extracted : return : Data extracted from the document \"\"\" endpoint_name = \" /documents/ \" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \" rb \" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \" utf-8 \" ) request_arguments = { \" file_name \" : file_name , \" file_data \" : base64_encoded_string , \" categories \" : categories , \" auto_delete \" : delete_after_processing , } document = self . _request ( \" POST \" , endpoint_name , request_arguments ) return document process_document_url def process_document_url ( self , file_url : Union [ str , NoneType ] = None , categories : Union [ List [ str ], NoneType ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Union [ str , NoneType ] = None , max_pages_to_process : Union [ int , NoneType ] = None , file_urls : Union [ List [ str ], NoneType ] = None ) -> Dict Process Document from url and extract all the fields from it Parameters: Name Type Description Default file_url None Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\" None file_urls None Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] None categories None List of categories to use when categorizing the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None max_pages_to_process None When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. None boost_mode None Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 None external_id None Optional custom document identifier. Use this if you would like to assign your own ID to documents None Returns: Type Description None Data extracted from the document View Source def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments ) update_document def update_document ( self , id : int , ** kwargs ) -> Dict Update data for a previously processed document, including almost any field like vendor , date , notes and etc. veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\") Parameters: Name Type Description Default kwargs None fields to update None Returns: Type Description None A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. View Source def update_document ( self , id : int , ** kwargs ) -> Dict : \" \"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\" \" endpoint_name = f \"/documents/{id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs )","title":"Index"},{"location":"reference/veryfi/#module-veryfi","text":"None None View Source import base64 import hashlib import hmac import json import os import time from typing import * import requests from veryfi.errors import VeryfiClientError class Client : API_VERSION = \"v7\" API_TIMEOUT = 120 MAX_FILE_SIZE_MB = 20 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\" , \"Automotive\" , \"Bank Charges & Fees\" , \"Legal & Professional Services\" , \"Insurance\" , \"Meals & Entertainment\" , \"Office Supplies & Software\" , \"Taxes & Licenses\" , \"Travel\" , \"Rent & Lease\" , \"Repairs & Maintenance\" , \"Payroll\" , \"Utilities\" , \"Job Supplies\" , \"Grocery\" , ] def __init__ ( self , client_id , client_secret , username = None , api_key = None , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ): self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . timeout = timeout self . api_version = api_version self . headers = {} self . _session = requests . Session () def _get_headers ( self , has_files : bool = False ): \"\"\" Prepares the headers needed for a request. :param has_files: Are there any files to be submitted as binary :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/0.1\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } if self . username : final_headers . update ( { \"Authorization\" : \"apikey {} : {} \" . format ( self . username , self . api_key )} ) if has_files : final_headers . pop ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) return final_headers def _get_url ( self ): \"\"\" Get API Base URL with API Version :return: Base URL to Veryfi API \"\"\" return self . base_url + self . api_version def _request ( self , http_verb , endpoint_name , request_arguments , file_stream = None ): \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" has_files = file_stream is not None headers = self . _get_headers ( has_files = has_files ) api_url = \" {0} /partner {1} \" . format ( self . _get_url (), endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200 , 201 , 202 , 204 ]: raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ): \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp: {} \" . format ( timestamp ) for key in payload_params . keys (): value = payload_params [ key ] payload = \" {0} , {1} : {2} \" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ) . digest () base64_signature = base64 . b64encode ( tmp_signature ) . decode ( \"utf-8\" ) . strip () return base64_signature def get_documents ( self ): \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ): \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/ {} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path , categories = None , delete_after_processing = False ): \"\"\" Process Document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def _process_document_file ( self , file_path , categories = None , delete_after_processing = False ): \"\"\" Process Document by sending it to Veryfi as multipart form :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) request_arguments = { \"file_name\" : file_name , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } with open ( file_path ) as file_stream : document = self . _request ( \"POST\" , endpoint_name , request_arguments , file_stream ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List [ str ]] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List [ str ]] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments ) def delete_document ( self , document_id ): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/ {0} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { id } /\" return self . _request ( \"PUT\" , endpoint_name , kwargs )","title":"Module veryfi"},{"location":"reference/veryfi/#sub-modules","text":"veryfi.errors","title":"Sub-modules"},{"location":"reference/veryfi/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/veryfi/#classes","text":"","title":"Classes"},{"location":"reference/veryfi/#client","text":"class Client ( client_id , client_secret , username = None , api_key = None , base_url = 'https://api.veryfi.com/api/' , api_version = 'v7' , timeout = 120 ) View Source class Client : API_VERSION = \"v7\" API_TIMEOUT = 120 MAX_FILE_SIZE_MB = 20 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\", \"Automotive\", \"Bank Charges & Fees\", \"Legal & Professional Services\", \"Insurance\", \"Meals & Entertainment\", \"Office Supplies & Software\", \"Taxes & Licenses\", \"Travel\", \"Rent & Lease\", \"Repairs & Maintenance\", \"Payroll\", \"Utilities\", \"Job Supplies\", \"Grocery\", ] def __init__ ( self , client_id , client_secret , username = None , api_key = None , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ) : self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . timeout = timeout self . api_version = api_version self . headers = {} self . _session = requests . Session () def _get_headers ( self , has_files : bool = False ) : \"\"\" Prepares the headers needed for a request. :param has_files: Are there any files to be submitted as binary :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/0.1\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } if self . username : final_headers . update ( { \"Authorization\" : \"apikey {}:{}\" . format ( self . username , self . api_key ) } ) if has_files : final_headers . pop ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) return final_headers def _get_url ( self ) : \"\"\" Get API Base URL with API Version :return: Base URL to Veryfi API \"\"\" return self . base_url + self . api_version def _request ( self , http_verb , endpoint_name , request_arguments , file_stream = None ) : \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" has_files = file_stream is not None headers = self . _get_headers ( has_files = has_files ) api_url = \"{0}/partner{1}\" . format ( self . _get_url (), endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200, 201, 202, 204 ] : raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ) : \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp:{}\" . format ( timestamp ) for key in payload_params . keys () : value = payload_params [ key ] payload = \"{0},{1}:{2}\" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ). digest () base64_signature = base64 . b64encode ( tmp_signature ). decode ( \"utf-8\" ). strip () return base64_signature def get_documents ( self ) : \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ) : \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/{}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def _process_document_file ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document by sending it to Veryfi as multipart form :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) request_arguments = { \"file_name\" : file_name , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } with open ( file_path ) as file_stream : document = self . _request ( \"POST\" , endpoint_name , request_arguments , file_stream ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments ) def delete_document ( self , document_id ) : \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/{0}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/{id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs )","title":"Client"},{"location":"reference/veryfi/#class-variables","text":"API_TIMEOUT API_VERSION BASE_URL CATEGORIES MAX_FILE_SIZE_MB","title":"Class variables"},{"location":"reference/veryfi/#methods","text":"","title":"Methods"},{"location":"reference/veryfi/#delete_document","text":"def delete_document ( self , document_id ) Delete Document from Veryfi Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_document(self, document_id): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = \"/documents/{0}/\".format(document_id) request_arguments = {\"id\": document_id} self._request(\"DELETE\", endpoint_name, request_arguments)","title":"delete_document"},{"location":"reference/veryfi/#get_document","text":"def get_document ( self , document_id ) Retrieve document by ID Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None Data extracted from the Document View Source def get_document ( self , document_id ) : \"\"\" Retrieve document by ID : param document_id : ID of the document you ' d like to retrieve :return : Data extracted from the Document \"\"\" endpoint_name = \" /documents/{}/ \" . format ( document_id ) request_arguments = { \" id \" : document_id } document = self . _request ( \" GET \" , endpoint_name , request_arguments ) return document","title":"get_document"},{"location":"reference/veryfi/#get_documents","text":"def get_documents ( self ) Get list of documents Returns: Type Description None List of previously processed documents View Source def get_documents ( self ) : \"\"\" Get list of documents : return : List of previously processed documents \"\"\" endpoint_name = \" /documents/ \" request_arguments = {} documents = self . _request ( \" GET \" , endpoint_name , request_arguments ) if \" documents \" in documents : return documents [ \" documents \" ] return documents","title":"get_documents"},{"location":"reference/veryfi/#process_document","text":"def process_document ( self , file_path , categories = None , delete_after_processing = False ) Process Document and extract all the fields from it Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None categories None List of categories Veryfi can use to categorize the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None Returns: Type Description None Data extracted from the document View Source def process_document ( self , file_path , categories = None , delete_after_processing = False ) : \"\"\" Process Document and extract all the fields from it : param file_path : Path on disk to a file to submit for data extraction : param categories : List of categories Veryfi can use to categorize the document : param delete_after_processing : Delete this document from Veryfi after data has been extracted : return : Data extracted from the document \"\"\" endpoint_name = \" /documents/ \" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \" rb \" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \" utf-8 \" ) request_arguments = { \" file_name \" : file_name , \" file_data \" : base64_encoded_string , \" categories \" : categories , \" auto_delete \" : delete_after_processing , } document = self . _request ( \" POST \" , endpoint_name , request_arguments ) return document","title":"process_document"},{"location":"reference/veryfi/#process_document_url","text":"def process_document_url ( self , file_url : Union [ str , NoneType ] = None , categories : Union [ List [ str ], NoneType ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Union [ str , NoneType ] = None , max_pages_to_process : Union [ int , NoneType ] = None , file_urls : Union [ List [ str ], NoneType ] = None ) -> Dict Process Document from url and extract all the fields from it Parameters: Name Type Description Default file_url None Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\" None file_urls None Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] None categories None List of categories to use when categorizing the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None max_pages_to_process None When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. None boost_mode None Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 None external_id None Optional custom document identifier. Use this if you would like to assign your own ID to documents None Returns: Type Description None Data extracted from the document View Source def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ) -> Dict : \"\"\" Process Document from url and extract all the fields from it :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \" :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this paremeter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } return self . _request ( \"POST\" , endpoint_name , request_arguments )","title":"process_document_url"},{"location":"reference/veryfi/#update_document","text":"def update_document ( self , id : int , ** kwargs ) -> Dict Update data for a previously processed document, including almost any field like vendor , date , notes and etc. veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\") Parameters: Name Type Description Default kwargs None fields to update None Returns: Type Description None A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. View Source def update_document ( self , id : int , ** kwargs ) -> Dict : \" \"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param kwargs: fields to update :return: A document json with updated fields, if fields are writible. Otherwise a document with unchanged fields. \"\" \" endpoint_name = f \"/documents/{id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs )","title":"update_document"},{"location":"reference/veryfi/errors/","text":"Module veryfi.errors None None View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) class UnauthorizedAccessToken ( VeryfiClientError ) : pass class BadRequest ( VeryfiClientError ) : pass class UnexpectedHTTPMethod ( VeryfiClientError ) : pass class AccessLimitReached ( VeryfiClientError ) : pass class InternalError ( VeryfiClientError ) : pass _error_map = { 400 : BadRequest , 401 : UnauthorizedAccessToken , 405 : UnexpectedHTTPMethod , 409 : AccessLimitReached , 500 : InternalError , } Classes AccessLimitReached class AccessLimitReached ( raw_response , ** error_info ) View Source class AccessLimitReached ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. BadRequest class BadRequest ( raw_response , ** error_info ) View Source class BadRequest ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InternalError class InternalError ( raw_response , ** error_info ) View Source class InternalError ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnauthorizedAccessToken class UnauthorizedAccessToken ( raw_response , ** error_info ) View Source class UnauthorizedAccessToken ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnexpectedHTTPMethod class UnexpectedHTTPMethod ( raw_response , ** error_info ) View Source class UnexpectedHTTPMethod ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. VeryfiClientError class VeryfiClientError ( raw_response , ** error_info ) View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants veryfi.errors.UnauthorizedAccessToken veryfi.errors.BadRequest veryfi.errors.UnexpectedHTTPMethod veryfi.errors.AccessLimitReached veryfi.errors.InternalError Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Errors"},{"location":"reference/veryfi/errors/#module-veryfierrors","text":"None None View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ()) class UnauthorizedAccessToken ( VeryfiClientError ) : pass class BadRequest ( VeryfiClientError ) : pass class UnexpectedHTTPMethod ( VeryfiClientError ) : pass class AccessLimitReached ( VeryfiClientError ) : pass class InternalError ( VeryfiClientError ) : pass _error_map = { 400 : BadRequest , 401 : UnauthorizedAccessToken , 405 : UnexpectedHTTPMethod , 409 : AccessLimitReached , 500 : InternalError , }","title":"Module veryfi.errors"},{"location":"reference/veryfi/errors/#classes","text":"","title":"Classes"},{"location":"reference/veryfi/errors/#accesslimitreached","text":"class AccessLimitReached ( raw_response , ** error_info ) View Source class AccessLimitReached ( VeryfiClientError ): pass","title":"AccessLimitReached"},{"location":"reference/veryfi/errors/#ancestors-in-mro","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#badrequest","text":"class BadRequest ( raw_response , ** error_info ) View Source class BadRequest ( VeryfiClientError ): pass","title":"BadRequest"},{"location":"reference/veryfi/errors/#ancestors-in-mro_1","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_1","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_1","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_1","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#internalerror","text":"class InternalError ( raw_response , ** error_info ) View Source class InternalError ( VeryfiClientError ): pass","title":"InternalError"},{"location":"reference/veryfi/errors/#ancestors-in-mro_2","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_2","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_2","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_2","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#unauthorizedaccesstoken","text":"class UnauthorizedAccessToken ( raw_response , ** error_info ) View Source class UnauthorizedAccessToken ( VeryfiClientError ): pass","title":"UnauthorizedAccessToken"},{"location":"reference/veryfi/errors/#ancestors-in-mro_3","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_3","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_3","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_3","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#unexpectedhttpmethod","text":"class UnexpectedHTTPMethod ( raw_response , ** error_info ) View Source class UnexpectedHTTPMethod ( VeryfiClientError ): pass","title":"UnexpectedHTTPMethod"},{"location":"reference/veryfi/errors/#ancestors-in-mro_4","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_4","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_4","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_4","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#veryficlienterror","text":"class VeryfiClientError ( raw_response , ** error_info ) View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"VeryfiClientError"},{"location":"reference/veryfi/errors/#ancestors-in-mro_5","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#descendants","text":"veryfi.errors.UnauthorizedAccessToken veryfi.errors.BadRequest veryfi.errors.UnexpectedHTTPMethod veryfi.errors.AccessLimitReached veryfi.errors.InternalError","title":"Descendants"},{"location":"reference/veryfi/errors/#class-variables_5","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_5","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" json_response = raw_response . json () # TODO Add Error Codes to API response # code = error_info . get ( \"code\" , \"\" ) try : error_cls = _error_map [ raw_response.status_code ] except KeyError : raise NotImplementedError ( \"Unknown error Please contact customer support at support@veryfi.com.\" ) else : return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_5","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"}]}